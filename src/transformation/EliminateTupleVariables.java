/**
 * 
 */
package transformation;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;

import logger.AreaAppender;
import minizinc.representation.expressions.ArrayAccess;
import minizinc.representation.expressions.Expr;
import minizinc.representation.expressions.ID;
import minizinc.representation.expressions.IdArrayAccess;
import minizinc.representation.expressions.Qualified;
import minizinc.representation.mznmodel.MiniZincSQLModel;
import minizinc.representation.statement.Decl;
import minizinc.representation.statement.Table;
import minizinc.representation.statement.decls.VarDecl;
import minizinc.representation.types.Type;
import minizinc.representation.types.TypeArray;
import minizinc.representation.types.TypeID;
import minizinc.representation.types.TypeSet;
import model.connection.SQLConnector;
import model.queries.Query;
import model.relation.ColumnMeta;
import model.relation.Database;
import model.relation.Relation;

/**
 * Replaces tuple variables by individual variables
 * 
 * @author rafa
 *
 *
 */
public class EliminateTupleVariables implements ExprTransformer {
	private static final Logger logger = AreaAppender.getLogger(EliminateTupleVariables.class);

	/**
	 * The substitution is represented by a binding.
	 */
	// protected HashMap<String, Expr> binding;

	/**
	 * The model to be modified
	 */
	protected MiniZincSQLModel mp;

	protected SQLConnector connector;

	protected Database db;

	protected boolean aborted;
	
	/**
	 * List of new variables generated by the last replacement
	 */
	List<VarDecl> newDecls;
	
	/**
	 * Removed variables and their replacement
	 */
	List<Replacement> replaced;
	
	
	/**
	 * Indicates if a new variable is a mixed variable
	 */
	List<Boolean> mixed;
	
	
	/**
	 * Name of the table sued to replace the last variable
	 */
	private String sqlName;

	/**
	 * Creates a constructor that initializes the binding associated to the
	 * substitution.
	 * 
	 * @param decls
	 * @param largs
	 */
	/*
	 * public EliminateTupleVariables(List<Decl> decls, List<Expr> largs) {
	 * String name; // the name of the variable in decl Decl decl; // the
	 * parameter declaration Expr expr; // the expression to bind the parameter
	 * 
	 * // build the bind, one by one for (int i = 0; i < decls.size(); i++) {
	 * decl = decls.get(i); expr = largs.get(i); name = decl.getID().print();
	 * put(name, expr);
	 * 
	 * }
	 * 
	 * }
	 */
	/**
	 * Constructor
	 * 
	 * @param db
	 * @param connector
	 */
	public EliminateTupleVariables(MiniZincSQLModel mp, SQLConnector connector, Database db) {
		// this.binding = null;
		this.mp = mp;
		this.connector = connector;
		this.db = db;
		this.aborted = false;
		replaced = new ArrayList<Replacement>();

		apply();
	}

	/**
	 * Apply the transformation
	 */
	private void apply() {
		String name; // the name of the variable in decl
		Decl decl; // the parameter declaration

		List<Decl> decls = mp.getDecl();
		
		// build the bind, one by one
		for (int i = decls.size()-1; i >=0; i--) {
			decl = decls.get(i);
			// at the moment params of type tuple are not supported
			if (decl instanceof VarDecl) {

				name = decl.getID().print();
				Type type = decl.getDeclType();
				logger.trace("Type: {} Name: {} ", type.toString(), name);
				// true if the declaration needs to be removed
				boolean delete = replaceTupleVar(type,name);
				if (delete){
					Replacement repl = new Replacement(this.sqlName,(VarDecl)decl,newDecls,mixed);
					replaced.add(repl);
					decls.remove(i);
				}
			}
		}

		// add the new declarations
		for (Replacement repl:replaced)
			  decls.addAll(repl.getNewDecls());
	}

	/**
	 * Replaces the i-th variable declaration, if its a tuple,
	 * by the jndividual components of its corresponding table
	 * @param i: position of the declaration analyzed in the list decls of the model
	 * @param type: type defining the declaration
	 * @param name: name of the variable
	 * @return true if the declaration is a tuple declaration
	 */
	private boolean replaceTupleVar(Type type, String name) {
		newDecls = new ArrayList<VarDecl>();
		mixed = new ArrayList<Boolean>();

		
		boolean isTuple=false;
		boolean isTypeID = type instanceof TypeID;
		boolean isTypeArray = type instanceof TypeArray;
		boolean isTypeSet = type instanceof TypeSet;
		
		boolean typeTuple = isTypeID || 
				            isTypeArray ||
				            isTypeSet;
	
		ColumnMeta[] replacement=null;
		if (typeTuple)
			isTuple=true;
		
		// get the column data to replace the variable
		if (isTypeID) replacement = checkType((TypeID) type);
		if (isTypeArray) {
			TypeArray ta = (TypeArray) type;
			Type base = ta.getBase();
			replacement = checkType((TypeID) base);
		}
		if (isTypeSet) {
			TypeSet ts = (TypeSet) type;
			Type elem = ts.getElem();
			if (elem instanceof TypeID)
				replacement = checkType((TypeID) elem);
			
		}
		
		// process the columns
		if (replacement != null) 
			for (ColumnMeta cm : replacement) {
				String colName = cm.getColumnName();
				Type typec = cm.getColumnType();
				boolean mixed = cm.getMixed();
				VarDecl newVar = null;
				if (isTypeID)
				    newVar= new VarDecl(typec,newVarName(name,colName,true));
				if (isTypeArray) {
					TypeArray newArray = new TypeArray(((TypeArray) type).getDimensions(), typec); 
					newVar= new VarDecl(newArray,newVarName(name,colName,true));
				}
				if (isTypeSet) {
					TypeSet newSet = new TypeSet(typec); 
					newVar= new VarDecl(newSet,newVarName(name,colName,true));					
				}
				newDecls.add(newVar);
				this.mixed.add(mixed);				
			}

						
		return isTuple;

	}

	/**
	 * Check if the type is a table type. In this case returns the types of the
	 * table attributes
	 * 
	 * @param type
	 * @return
	 */
	private ColumnMeta[] checkType(TypeID type) {
		ColumnMeta[] r = null;
		ID id = type.getId();
		Table t = this.mp.getTableByName(id.print());
		if (t != null) {
			sqlName = t.getString().print();
			sqlName = sqlName.substring(1, sqlName.length() - 1);
			Relation rel = db.getRelation(sqlName);
			if (rel == null) {
				logger.error("Declared SQL table {} does not exist!", sqlName);
				aborted = true;
			} else {
				try {
					r = Query.getColumns(connector.getConnection(), sqlName);
				} catch (SQLException e) {
					logger.error("Error getting column metada for table {}", sqlName);

				}
			}

		} else {
			logger.error("Type table {} used in var. declaration needs to be declared with the reserved word table!",
					type);
			aborted = true;
		}

		return r;
	}
	
	/**
	 * @param originalName Name of the variable to be replaced
	 * @param colName Columnname
	 * @param decl <ul>
	 *             <li>true if we are looking for generating a new variable
	 *             <li>false if we are accessing to an already existing variable
	 *             </ul>
	 *             
	 * @return Name of the variable
	 */
	private String newVarName(String originalName, String colName, boolean decl) {
		String r = originalName+"_"+colName;
		// if this for a variable declaration we need to check that the name is really new
		VarDecl var = mp.getVarByName(new ID(r));
		if (decl) {
		// the variable name is not new, generate a new one
		if (var!=null) {
			int i=0;
			do {
				i++;
				r = originalName+"_"+colName + "_"+i;
				var = mp.getVarByName(new ID(r));
			} while(var!=null);
			
		} 
		} else {
			// if it is a variable access we need to check that variable exists
			if (var==null) {
				int i=0;
				do {
					i++;
					r = originalName+"_"+colName + "_"+i;
					var = mp.getVarByName(new ID(r));
				} while(var==null);				
			}
		}
			
		return r;
		
	}

	/**
	 * A new binding (name, expr).
	 * 
	 * @param name
	 *            String with the variable name.
	 * @param expr
	 *            Value
	 */
	/*
	 * public void put(String name, Expr expr) { if (binding == null) binding =
	 * new HashMap<String, Expr>(); binding.put(name, expr); }
	 */

	/*
	 * (non-Javadoc)
	 * 
	 * @see transformation.ExprTransformer#transform(minizinc.representation.
	 * expressions .Expr)
	 */
	/**
	 * Transforms qualified data
	 */
	@Override
	public Expr transform(Expr input) {
		Expr r = null;
		if (input instanceof Qualified){
			Qualified qlf = (Qualified) input;
			ID id2 = qlf.getId2();
			if (qlf.getArrayAccess()!=null) {
				ArrayAccess aa = qlf.getArrayAccess();
				if (aa instanceof IdArrayAccess){
					IdArrayAccess iaa = (IdArrayAccess) aa;
					ID idarray = iaa.getID();
					String newName = newVarName(idarray.print(),id2.print(),false);
					iaa.setID(new ID(newName));
					r=iaa;
				}
				
				
			} else {
				ID id1 = qlf.getId1();
				String newName = newVarName(id1.print(),id2.print(),false);
				r = new ID(newName);
				
			}
				
				
		}
		return r;
	}

	@Override
	public String toString() {
		String r = "";
		return r;
	}

	public boolean aborted() {

		return aborted;
	}
	

	public List<Replacement> getReplaced() {
		return this.replaced;
	}

}
